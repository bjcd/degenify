<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Degenify</title>
  <link rel="icon" type="image/png" href="/hat-logo.png">
  <meta name="description"
    content="Degenify any situation with our purple hat mascot character using AI image generation. Create unique, fun images instantly." />

  <!-- Open Graph Meta Tags for Farcaster Embed -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="Degenify">
  <meta property="og:description"
    content="Degenify any situation with our purple hat mascot character using AI image generation. Create unique, fun images instantly.">
  <meta property="og:image" content="https://www.degenify.xyz/miniapp-icon.png">
  <meta property="og:image:width" content="512">
  <meta property="og:image:height" content="512">
  <meta property="og:image:type" content="image/png">
  <meta property="og:url" content="https://www.degenify.xyz">
  <meta property="og:site_name" content="Degenify">

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Degenify">
  <meta name="twitter:description"
    content="Degenify any situation with our purple hat mascot character using AI image generation. Create unique, fun images instantly.">
  <meta name="twitter:image" content="https://www.degenify.xyz/miniapp-icon.png">

  <!-- Farcaster Mini App Meta Tags -->
  <meta name="fc:miniapp" content='{
    "version": "1",
    "imageUrl": "https://www.degenify.xyz/miniapp-icon-large.png",
    "button": {
      "title": "Open mini app",
      "action": {
        "type": "launch_frame",
        "name": "Degenify",
        "url": "https://www.degenify.xyz",
        "splashImageUrl": "https://www.degenify.xyz/miniapp-icon.png",
        "splashBackgroundColor": "#e8d3f4"
      }
    }
  }'>

  <!-- Manifest Link -->
  <link rel="manifest" href="/.well-known/farcaster.json">


  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    /* Degenify Design System - Gen Z Minimalist Aesthetic */
    :root {
      /* Base colors */
      --background: 0 0% 100%;
      --foreground: 240 10% 3.9%;

      /* Purple theme - enhanced for slicker look */
      --primary: 267 83% 58%;
      /* Vibrant purple */
      --primary-foreground: 0 0% 100%;
      --primary-light: 267 83% 70%;
      --primary-dark: 267 83% 45%;
      --primary-glow: 267 83% 65%;

      /* Secondary purple tones */
      --secondary: 267 30% 97%;
      --secondary-foreground: 267 83% 25%;

      /* Accent colors - enhanced */
      --accent: 280 100% 70%;
      /* Pink-purple accent */
      --accent-foreground: 0 0% 100%;
      --accent-secondary: 290 100% 75%;
      /* Additional accent */

      /* Neutral tones - refined */
      --muted: 220 14.3% 95.9%;
      --muted-foreground: 220 8.9% 46.1%;

      /* UI elements - enhanced */
      --card: 0 0% 100%;
      --card-foreground: 240 10% 3.9%;
      --popover: 0 0% 100%;
      --popover-foreground: 240 10% 3.9%;
      --border: 267 20% 90%;
      --input: 267 15% 92%;
      --ring: 267 83% 58%;

      /* Status colors */
      --destructive: 0 84.2% 60.2%;
      --destructive-foreground: 210 40% 98%;

      /* Enhanced gradients for slicker look */
      --gradient-mesh: radial-gradient(circle at 20% 80%, hsl(267 83% 58% / 0.3) 0%, transparent 50%), radial-gradient(circle at 80% 20%, hsl(280 100% 70% / 0.3) 0%, transparent 50%);
      --gradient-primary: linear-gradient(135deg, hsl(267 83% 58%), hsl(280 100% 70%), hsl(290 100% 75%));
      --gradient-subtle: linear-gradient(180deg, hsl(0 0% 100%), hsl(267 15% 98%));
      --gradient-card: linear-gradient(145deg, hsl(0 0% 100%) 0%, hsl(267 20% 97%) 100%);
      --gradient-glass: linear-gradient(135deg, hsl(0 0% 100% / 0.1), hsl(267 83% 58% / 0.1));

      /* Enhanced shadows */
      --shadow-soft: 0 4px 20px hsl(267 83% 58% / 0.15);
      --shadow-glow: 0 0 40px hsl(267 83% 58% / 0.4);
      --shadow-card: 0 12px 40px hsl(240 10% 3.9% / 0.1);
      --shadow-intense: 0 20px 60px hsl(267 83% 58% / 0.25);

      /* Animation properties - enhanced */
      --transition-smooth: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-bounce: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      --transition-glass: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);

      --radius: 1rem;
      /* More generous radius for modern look */
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: var(--gradient-mesh);
      color: hsl(var(--foreground));
      margin: 0;
      padding: 0;
      min-height: 100vh;
      line-height: 1.6;
    }

    html {
      background: var(--gradient-mesh);
      scroll-behavior: smooth;
    }

    /* Enhanced button variants */
    .btn-degenify {
      background: var(--gradient-primary);
      color: hsl(var(--primary-foreground));
      font-weight: 700;
      padding: 1.5rem 3rem;
      border-radius: 1.5rem;
      box-shadow: var(--shadow-intense);
      border: none;
      cursor: pointer;
      transition: var(--transition-smooth);
      position: relative;
      overflow: hidden;
      font-size: 1.25rem;
      height: 4rem;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.75rem;
    }

    .btn-degenify:hover {
      box-shadow: var(--shadow-glow);
      transform: scale(1.05);
    }

    .btn-degenify:active {
      transform: scale(0.95);
    }

    .btn-degenify:disabled {
      opacity: 0.6;
      cursor: pointer;
      transform: none;
    }

    .btn-degenify::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transform: translateX(-100%) skewX(12deg);
      transition: transform 0.7s;
    }

    .btn-degenify:hover::before {
      transform: translateX(100%);
    }

    .btn-secondary {
      background: hsl(var(--secondary) / 0.8);
      backdrop-filter: blur(4px);
      color: hsl(var(--secondary-foreground));
      font-weight: 500;
      padding: 0.75rem 1.5rem;
      border-radius: 1rem;
      border: 1px solid hsl(var(--border) / 0.5);
      cursor: pointer;
      transition: var(--transition-smooth);
      font-size: 0.875rem;
    }

    .btn-secondary:hover {
      background: hsl(var(--primary) / 0.1);
      border-color: hsl(var(--primary) / 0.3);
      box-shadow: var(--shadow-soft);
      transform: scale(1.05);
    }

    /* Mascot Toggle Switch */
    .mascot-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
      padding: 1rem;
      background: hsl(var(--card) / 0.6);
      backdrop-filter: blur(4px);
      border: 1px solid hsl(var(--border) / 0.3);
      border-radius: 1rem;
      transition: var(--transition-smooth);
    }

    /* Hide only the toggle switch in miniapp, keep the squares visible */
    @media (max-width: 768px) {
      .toggle-switch {
        display: none;
      }
    }

    .mascot-toggle:hover {
      background: hsl(var(--card) / 0.8);
      box-shadow: var(--shadow-soft);
    }

    .mascot-label {
      font-weight: 600;
      color: hsl(var(--foreground));
      font-size: 1.1rem;
    }

    .toggle-switch {
      position: relative;
      width: 60px;
      height: 32px;
      background: hsl(var(--muted));
      border-radius: 16px;
      cursor: pointer;
      transition: var(--transition-smooth);
      border: 2px solid hsl(var(--border) / 0.3);
    }

    .toggle-switch.active {
      background: linear-gradient(135deg, hsl(var(--primary)), hsl(var(--accent)));
      border-color: hsl(var(--primary));
      box-shadow: 0 0 20px hsl(var(--primary) / 0.3);
    }

    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 24px;
      height: 24px;
      background: white;
      border-radius: 50%;
      transition: var(--transition-smooth);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .toggle-switch.active .toggle-slider {
      transform: translateX(28px);
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
    }

    .mascot-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
      color: hsl(var(--muted-foreground));
      transition: var(--transition-smooth);
    }

    .mascot-option.active {
      color: hsl(var(--primary));
      font-weight: 600;
    }

    .mascot-icon {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      object-fit: cover;
    }

    /* Mobile-specific fixes for mascot toggle - more subtle */
    @media (max-width: 768px) {
      .mascot-toggle {
        flex-direction: row;
        gap: 0.5rem;
        padding: 0.75rem;
        margin-bottom: 1rem;
        background: hsl(var(--card) / 0.4);
        border: 1px solid hsl(var(--border) / 0.2);
      }

      .mascot-option {
        font-size: 0.85rem;
        padding: 0.4rem 0.6rem;
        border-radius: 0.4rem;
        min-height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex: 1;
        background: transparent;
        border: 1px solid transparent;
        transition: var(--transition-smooth);
        opacity: 0.7;
      }

      .mascot-option.active {
        background: hsl(var(--primary) / 0.15);
        border-color: hsl(var(--primary) / 0.3);
        opacity: 1;
        font-weight: 600;
      }

      .mascot-option:active {
        transform: scale(0.96);
      }

      .toggle-switch {
        width: 50px;
        height: 28px;
        border-radius: 14px;
        margin: 0;
        padding: 2px;
        flex-shrink: 0;
      }

      .toggle-slider {
        width: 20px;
        height: 20px;
        top: 2px;
        left: 2px;
      }

      .toggle-switch.active .toggle-slider {
        transform: translateX(22px);
      }

      .mascot-icon {
        width: 16px;
        height: 16px;
        margin-right: 0.3rem;
      }

      /* Ensure proper touch handling */
      .toggle-switch,
      .mascot-option {
        -webkit-tap-highlight-color: transparent;
        user-select: none;
        -webkit-user-select: none;
        touch-action: manipulation;
      }
    }

    /* Very small screens - even more compact */
    @media (max-width: 480px) {
      .mascot-toggle {
        padding: 0.6rem;
        gap: 0.4rem;
        margin-bottom: 0.75rem;
      }

      .mascot-option {
        font-size: 0.8rem;
        padding: 0.35rem 0.5rem;
        min-height: 32px;
      }

      .toggle-switch {
        width: 45px;
        height: 26px;
        border-radius: 13px;
      }

      .toggle-slider {
        width: 18px;
        height: 18px;
      }

      .toggle-switch.active .toggle-slider {
        transform: translateX(19px);
      }

      .mascot-icon {
        width: 14px;
        height: 14px;
        margin-right: 0.25rem;
      }
    }

    /* Enhanced input styles */
    .input-degenify {
      width: 100%;
      padding: 1.5rem 2rem;
      background: hsl(var(--card) / 0.8);
      backdrop-filter: blur(4px);
      border: 2px solid hsl(var(--border) / 0.5);
      border-radius: 1.5rem;
      color: hsl(var(--foreground));
      font-size: 1.25rem;
      font-weight: 500;
      min-height: 140px;
      resize: none;
      transition: var(--transition-smooth);
      box-shadow: var(--shadow-card);
    }

    .input-degenify::placeholder {
      color: hsl(var(--muted-foreground));
    }

    .input-degenify:focus {
      outline: none;
      border-color: hsl(var(--primary));
      box-shadow: 0 0 0 4px hsl(var(--primary) / 0.2);
    }

    .input-degenify:hover {
      box-shadow: var(--shadow-soft);
    }

    /* Enhanced card styles */
    .card-degenify {
      background: hsl(var(--card) / 0.9);
      backdrop-filter: blur(4px);
      border: 1px solid hsl(var(--border) / 0.3);
      border-radius: 1.5rem;
      padding: 2rem;
      box-shadow: var(--shadow-card);
      transition: var(--transition-smooth);
      position: relative;
      overflow: hidden;
    }

    .card-degenify:hover {
      box-shadow: var(--shadow-intense);
      transform: scale(1.02);
      border-color: hsl(var(--primary) / 0.2);
    }

    .card-glass {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 1.5rem;
      box-shadow: var(--shadow-intense);
      transition: var(--transition-smooth);
      padding: 1rem;
      position: relative;
      overflow: hidden;
    }

    .card-glass:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .card-glass::before {
      content: '';
      position: absolute;
      inset: 0;
      background: var(--gradient-primary);
      opacity: 0;
      transition: opacity 0.3s;
    }

    .card-glass:hover::before {
      opacity: 0.1;
    }

    /* Loading animation enhanced */
    .hat-spin {
      animation: hatSpinEnhanced 2s ease-in-out infinite;
    }

    .hat-pulse {
      animation: hatPulseEnhanced 1.5s ease-in-out infinite;
    }

    /* Utilities */
    .text-gradient {
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: transparent;
    }

    .bg-gradient-degenify {
      background: var(--gradient-primary);
    }

    .bg-gradient-mesh {
      background: var(--gradient-mesh);
    }

    .bg-gradient-subtle {
      background: var(--gradient-subtle);
    }


    .shadow-glow {
      box-shadow: var(--shadow-glow);
    }

    .shadow-intense {
      box-shadow: var(--shadow-intense);
    }

    .shadow-soft {
      box-shadow: var(--shadow-soft);
    }

    .glass-effect {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* Gallery styles - matching GitHub exactly */
    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 2rem;
      margin-top: 2rem;
    }

    .gallery-item {
      position: relative;
      transition: var(--transition-smooth);
    }

    .gallery-item:hover {
      transform: scale(1.02);
    }

    .gallery-image-container {
      position: relative;
      overflow: hidden;
      border-radius: 1rem;
      margin-bottom: 1rem;
      box-shadow: var(--shadow-intense);
    }

    .gallery-item img {
      width: 100%;
      height: 16rem;
      object-fit: cover;
      transition: var(--transition-smooth);
    }

    .gallery-item:hover img {
      transform: scale(1.1);
    }

    /* Hover Overlay - matching GitHub exactly */
    .gallery-overlay {
      position: absolute;
      inset: 0;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.2), transparent);
      opacity: 0;
      transition: opacity 0.3s;
    }

    .gallery-item:hover .gallery-overlay {
      opacity: 1;
    }

    /* Mobile: Always show overlay on touch devices */
    @media (hover: none) and (pointer: coarse) {
      .gallery-overlay {
        opacity: 1;
        background: linear-gradient(to top, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.3), transparent);
      }
    }

    .gallery-overlay-content {
      position: absolute;
      bottom: 1rem;
      left: 1rem;
      right: 1rem;
    }

    .gallery-prompt {
      color: hsl(var(--muted-foreground));
      font-size: 0.875rem;
      font-weight: 500;
      line-height: 1.4;
      margin: 0.75rem 0 0 0;
      word-break: break-word;
    }

    .gallery-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .gallery-action-group {
      display: flex;
      gap: 0.5rem;
    }

    .gallery-action-btn {
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(4px);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      border-radius: 0.5rem;
      padding: 0.5rem;
      cursor: pointer;
      transition: var(--transition-smooth);
      display: flex;
      align-items: center;
      justify-content: center;
      width: 2rem;
      height: 2rem;
    }

    .gallery-action-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .gallery-download-btn {
      background: hsl(var(--primary) / 0.8);
      backdrop-filter: blur(4px);
      border: 1px solid hsl(var(--primary));
      color: white;
      border-radius: 0.5rem;
      padding: 0.5rem;
      cursor: pointer;
      transition: var(--transition-smooth);
      display: flex;
      align-items: center;
      justify-content: center;
      width: 2rem;
      height: 2rem;
    }

    .gallery-download-btn:hover {
      background: hsl(var(--primary));
    }

    /* Mobile: Make buttons larger and more touch-friendly */
    @media (hover: none) and (pointer: coarse) {
      .gallery-action-btn {
        padding: 0.75rem;
        min-width: 44px;
        min-height: 44px;
        width: auto;
        height: auto;
      }

      .gallery-download-btn {
        padding: 0.75rem;
        min-width: 44px;
        min-height: 44px;
      }

      .gallery-action-btn svg,
      .gallery-download-btn svg {
        width: 20px;
        height: 20px;
      }
    }


    .loading {
      text-align: center;
      color: hsl(var(--muted-foreground));
      margin: 2rem 0;
    }

    /* Animations */
    @keyframes hatSpinEnhanced {

      0%,
      100% {
        transform: rotate(0deg) scale(1);
        filter: hue-rotate(0deg);
      }

      25% {
        transform: rotate(90deg) scale(1.15);
        filter: hue-rotate(45deg);
      }

      50% {
        transform: rotate(180deg) scale(1.3);
        filter: hue-rotate(90deg);
      }

      75% {
        transform: rotate(270deg) scale(1.15);
        filter: hue-rotate(135deg);
      }
    }

    @keyframes hatPulseEnhanced {

      0%,
      100% {
        transform: scale(1);
        opacity: 1;
        filter: brightness(1);
      }

      50% {
        transform: scale(1.2);
        opacity: 0.8;
        filter: brightness(1.3);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(40px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .animate-fade-in {
      animation: fadeIn 0.6s ease-out;
    }

    .animate-slide-up {
      animation: slideUp 0.8s ease-out;
    }

    /* Layout */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 1.5rem;
      text-align: center;
    }

    .header {
      padding: 1rem 0 0.5rem;
      text-align: center;
    }

    .main {
      padding: 0.5rem 0;
      text-align: center;
    }

    .footer {
      padding: 2rem 0;
      text-align: center;
      border-top: 1px solid hsl(var(--border) / 0.3);
    }

    .examples {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: center;
      margin-top: 1rem;
    }

    .example-btn {
      background: hsl(var(--secondary) / 0.8);
      backdrop-filter: blur(4px);
      color: hsl(var(--secondary-foreground));
      font-weight: 500;
      padding: 0.5rem 1rem;
      border-radius: 1rem;
      border: 1px solid hsl(var(--border) / 0.5);
      cursor: pointer;
      transition: var(--transition-smooth);
      font-size: 0.875rem;
    }

    .example-btn:hover {
      background: hsl(var(--primary) / 0.1);
      border-color: hsl(var(--primary) / 0.3);
      box-shadow: var(--shadow-soft);
      transform: scale(1.05);
    }

    .char-count {
      font-size: 0.875rem;
      color: hsl(var(--muted-foreground));
      font-weight: 500;
    }

    .hint {
      display: block;
      color: hsl(var(--muted-foreground));
      font-size: 0.875rem;
    }

    .text-left {
      text-align: left;
    }

    .text-right {
      text-align: right;
    }

    .logo-text-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }

    .logo-text-container img {
      vertical-align: middle;
      transform: translateY(-2px);
    }

    .sparkles {
      animation: spin 1s linear infinite;
    }

    /* Share Modal Styles */
    .share-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.2);
      backdrop-filter: blur(2px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease-out;
    }

    .share-modal {
      background: white;
      border-radius: 1rem;
      padding: 0;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      border: 1px solid rgba(0, 0, 0, 0.1);
      animation: slideUp 0.3s ease-out;
    }

    .share-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1.5rem 1.5rem 1rem 1.5rem;
      border-bottom: 1px solid #e5e7eb;
    }

    .share-modal-header h3 {
      margin: 0;
      color: #1f2937;
      font-size: 1.25rem;
      font-weight: 600;
    }

    .share-modal-close {
      background: none;
      border: none;
      color: #6b7280;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 0.5rem;
      transition: var(--transition-smooth);
    }

    .share-modal-close:hover {
      background: rgba(0, 0, 0, 0.05);
      color: #1f2937;
    }

    .share-modal-content {
      padding: 1.5rem;
    }

    .share-modal-content p {
      margin: 0 0 1rem 0;
      color: #6b7280;
      text-align: center;
    }

    .share-options {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .share-option-btn {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 1rem;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 0.75rem;
      color: #1f2937;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition-smooth);
      text-align: left;
    }

    .share-option-btn:hover {
      background: #f3f4f6;
      border-color: #d1d5db;
      transform: translateY(-1px);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .share-option-btn svg {
      flex-shrink: 0;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
      }

      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    .loading-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 5rem 0;
    }

    .loading-hat {
      width: 5rem;
      height: 5rem;
      animation: hatSpinEnhanced 2s ease-in-out infinite;
      filter: drop-shadow(0 0 20px hsl(var(--primary) / 0.5));
    }

    .loading-text {
      margin-top: 1.5rem;
      text-align: center;
    }

    .loading-text h3 {
      font-size: 1.125rem;
      font-weight: 700;
      color: hsl(var(--foreground));
      margin: 0 0 0.5rem 0;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .loading-text p {
      font-size: 0.875rem;
      color: hsl(var(--muted-foreground));
      margin: 0;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.7;
      }
    }

    .result-image {
      max-width: 100%;
      border-radius: 1rem;
      box-shadow: var(--shadow-intense);
      margin-top: 2rem;
      transition: var(--transition-smooth);
    }

    .result-image:hover {
      transform: scale(1.02);
    }

    .empty-gallery {
      text-align: center;
      padding: 3rem 1rem;
      color: hsl(var(--muted-foreground));
    }

    .empty-gallery h3 {
      font-size: 1.25rem;
      font-weight: 600;
      margin: 0 0 0.5rem 0;
    }

    .empty-gallery p {
      font-size: 0.875rem;
      margin: 0;
    }
  </style>
</head>

<body>
  <div class="min-h-screen">
    <!-- Header -->
    <header class="header text-center">
      <div class="container text-center">
        <div class="flex flex-col items-center justify-center space-y-2 animate-fade-in">

          <h1 class="text-3xl font-bold text-gradient logo-text-container">
            <img src="/hat-logo.png" alt="Degenify"
              class="drop-shadow-lg hover:scale-110 transition-transform duration-300"
              style="width: 48px; height: 48px;" />
            <span>Degenify</span>
          </h1>

          <button onclick="addToFarcaster()" class="add-to-farcaster-btn"
            style="display: none; background: linear-gradient(135deg, #8b5cf6, #ec4899); color: white; border: none; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
              style="margin-right: 8px; vertical-align: middle;">
              <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
            </svg>
            Add miniapp to Farcaster
          </button>
        </div>
      </div>
    </header>

    <!-- Main Generator Section -->
    <main class="main text-center">
      <div class="container text-center">
        <div class="text-center mb-2 animate-slide-up">
          <h2 class="text-2xl font-bold text-foreground mb-2 text-center">
            Make any situation degenerate
          </h2>
          <p class="text-muted-foreground text-center">
            Describe what you want and watch the magic happen
          </p>
        </div>

        <!-- Generator Form -->
        <div class="w-full max-w-4xl mx-auto">
          <div id="generator-form" class="space-y-8 animate-fade-in">
            <!-- Main Generator Card -->
            <div class="card-degenify relative overflow-hidden">
              <div class="absolute inset-0 opacity-30"></div>
              <div class="relative space-y-6">
                <!-- Mascot Toggle Switch -->
                <div class="mascot-toggle">
                  <div class="mascot-option active" id="mascot-option">
                    <img src="base.png" alt="Mascot" class="mascot-icon">
                    <span>Mascot</span>
                  </div>
                  <div class="toggle-switch" id="mascot-toggle">
                    <div class="toggle-slider"></div>
                  </div>
                  <div class="mascot-option" id="cyberpunk-option">
                    <img src="base-cyberpunk.png" alt="Cyberpunk" class="mascot-icon">
                    <span>Cyberpunk</span>
                  </div>
                  <div class="mascot-option" id="pfp-option" style="display: none;">
                    <img
                      src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTAiIGZpbGw9IiM4QjNCRUQiLz4KPHBhdGggZD0iTTEyIDJMMTQuNSA5SDE5LjVMMTUuNzUgMTMuNUwxNy41IDE5TDEyIDE2TDUuNSAxOUw3LjI1IDEzLjVMMi41IDlINy41TDEyIDJaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K"
                      alt="PFP" class="mascot-icon">
                    <span>Pfp</span>
                  </div>
                </div>

                <div class="space-y-4">
                  <textarea id="prompt"
                    placeholder="Describe any wild situation... (e.g., 'riding a dragon through neon city')"
                    class="input-degenify" maxlength="500"></textarea>

                  <div class="flex justify-between items-center text-sm mb-4">
                    <span id="char-count" class="char-count">
                      0/500 characters
                    </span>
                  </div>
                </div>

                <button id="generate-btn" class="btn-degenify group relative overflow-hidden">
                  <div class="flex items-center justify-center space-x-3 relative z-10">
                    <span class="sparkles">‚ú®</span>
                    <span class="font-bold">Degenify üé©</span>
                    <span class="sparkles">‚ú®</span>
                  </div>
                </button>
              </div>
            </div>

            <!-- Quick Examples -->
            <div class="space-y-4">
              <p class="text-center text-muted-foreground font-medium text-center">
                üî• Popular vibes:
              </p>
              <div class="examples">
                <button class="example-btn"
                  data-prompt="Surfing massive waves, in a Hawaiian style landscape, sharks and dolphins around.">üèÑ‚Äç‚ôÇÔ∏è
                  surfing massive waves</button>
                <button class="example-btn"
                  data-prompt="Performing on stage, electric guitar, massive festival/concert">üé∏ performing on
                  stage</button>
                <button class="example-btn" data-prompt="Exploring space, astronaut outfit, space shuttle nearby">üöÄ
                  exploring space</button>
                <button class="example-btn" data-prompt="Being a chef, cooking sushis in a Japanese restaurant">üç≥ being
                  a chef</button>
                <button class="example-btn" data-prompt="Climbing mountains. Climbing outfit, snow">üèîÔ∏è climbing
                  mountains</button>
                <button class="example-btn"
                  data-prompt="In a video game. 3d style, loading bars and life bars, fighting other 3 characters. Video game UI on the screen">üéÆ
                  in a video game</button>
              </div>
            </div>
          </div>

          <!-- Loading State -->
          <div id="loading-state" class="loading-container" style="display: none;">
            <img src="/hat-logo.png" alt="Degenify Hat" class="loading-hat" style="width: 80px; height: 80px;" />
            <div class="loading-text">
              <h3>‚ú® Degenifying your situation... ‚ú®</h3>
              <p>This is about to be absolutely fire üî•</p>
            </div>
          </div>
        </div>

        <!-- Result Image -->
        <div id="result-container" class="text-center" style="display: none;">
          <img id="result-image" class="result-image" alt="Generated image" />
        </div>

        <!-- Gallery Section -->
        <section class="py-16">
          <div class="text-center mb-20">
            <h1 class="text-3xl font-bold text-gradient">
              Epic Degenerations
            </h1>
            <p class="text-xl text-muted-foreground max-w-2xl mx-auto text-center mb-8">
              The community is going absolutely wild with these generations üî•
            </p>
          </div>

          <div id="gallery" class="gallery"></div>

          <!-- Loading indicator for infinite scroll -->
          <div id="loadingIndicator" class="text-center py-8 hidden">
            <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-purple-500"></div>
            <p class="text-muted-foreground mt-2">Loading more generations...</p>
          </div>
        </section>
      </div>
    </main>

    <!-- Footer -->
    <footer class="footer">
      <div class="container">
        <p class="text-sm text-muted-foreground">
          Made with üíú for the degen community
        </p>
      </div>
    </footer>
  </div>

  <script type="module">
    const generateBtn = document.getElementById('generate-btn');
    const promptInput = document.getElementById('prompt');
    const charCount = document.getElementById('char-count');
    const generatorForm = document.getElementById('generator-form');
    const loadingState = document.getElementById('loading-state');
    const resultContainer = document.getElementById('result-container');
    const resultImage = document.getElementById('result-image');
    const gallery = document.getElementById('gallery');

    // Mascot toggle variables
    const mascotToggle = document.getElementById('mascot-toggle');
    const mascotOption = document.getElementById('mascot-option');
    const cyberpunkOption = document.getElementById('cyberpunk-option');
    const pfpOption = document.getElementById('pfp-option');
    let isMascotMode = true; // Default to mascot mode
    let isPfpMode = false; // PFP mode flag
    let currentBaseImage = 'base.png';
    let currentPromptContext = 'A cute purple hat character with a friendly face, wearing a stylish purple top hat. The character should always maintain the distinctive purple hat while the pose, expression, and clothing can be modified.';
    let userPfpUrl = null; // Store user's PFP URL

    // Character count update and button state
    promptInput.addEventListener('input', () => {
      const count = promptInput.value.length;
      charCount.textContent = `${count}/500 characters`;

      // Enable/disable button based on input
      generateBtn.disabled = count === 0;
      console.log('Input changed, count:', count, 'disabled:', generateBtn.disabled);
    });

    // Mascot toggle functionality
    function updateToggleState() {
      if (isMascotMode) {
        mascotToggle.classList.remove('active');
        mascotOption.classList.add('active');
        cyberpunkOption.classList.remove('active');
        pfpOption.classList.remove('active');
        currentBaseImage = 'base.png';
        currentPromptContext = 'A cute purple hat character with a friendly face, wearing a stylish purple top hat. The character should always maintain the distinctive purple hat while the pose, expression, and clothing can be modified.';
        promptInput.placeholder = "Describe any wild situation... (e.g., 'riding a dragon through neon city')";
      } else if (isPfpMode) {
        mascotToggle.classList.add('active');
        mascotOption.classList.remove('active');
        cyberpunkOption.classList.remove('active');
        pfpOption.classList.add('active');
        currentBaseImage = userPfpUrl || 'base.png'; // Use user's PFP or fallback
        currentPromptContext = 'Add a stylish purple top hat to this person\'s profile picture. The purple top hat must be prominent and well-integrated with their appearance. Maintain their facial features and overall look while adding the distinctive purple hat. Make it look natural and stylish.';
        promptInput.placeholder = "Describe the style for your degenified PFP... (e.g., 'cyberpunk style', 'elegant formal look')";
      } else {
        mascotToggle.classList.add('active');
        mascotOption.classList.remove('active');
        cyberpunkOption.classList.add('active');
        pfpOption.classList.remove('active');
        currentBaseImage = 'base-cyberpunk.png';
        currentPromptContext = 'A cinematic hyper-realistic 3D render of a deep velvet purple top hat with a gold band. The purple top hat must ALWAYS be visible and prominent in the image. Set in a neon cyberpunk atmosphere with rich textures, dramatic lighting, glowing purple energy, cinematic depth of field, futuristic gritty environment, and moody atmosphere. The hat should be the focal point of the composition.';
        promptInput.placeholder = "Describe any wild situation... (e.g., 'riding a dragon through neon city')";
      }
    }

    // Toggle switch click handler - cycle through modes (desktop only)
    mascotToggle.addEventListener('click', () => {
      // Only work on desktop, not in miniapp
      if (window.location !== window.parent.location) {
        return; // Skip in miniapp
      }

      if (isMascotMode) {
        isMascotMode = false;
        isPfpMode = false;
        // Go to cyberpunk mode
      } else if (isPfpMode) {
        isMascotMode = true;
        isPfpMode = false;
        // Go back to mascot mode
      } else {
        // Currently in cyberpunk mode, check if PFP option is available
        if (pfpOption.style.display !== 'none') {
          isMascotMode = false;
          isPfpMode = true;
        } else {
          isMascotMode = true;
          isPfpMode = false;
        }
      }
      updateToggleState();
    });

    // Mobile-friendly option click handlers
    mascotOption.addEventListener('click', () => {
      if (!isMascotMode) {
        isMascotMode = true;
        isPfpMode = false;
        updateToggleState();
      }
    });

    cyberpunkOption.addEventListener('click', () => {
      if (isMascotMode || isPfpMode) {
        isMascotMode = false;
        isPfpMode = false;
        updateToggleState();
      }
    });

    pfpOption.addEventListener('click', () => {
      if (!isPfpMode) {
        isMascotMode = false;
        isPfpMode = true;
        updateToggleState();
      }
    });

    // Initialize toggle state
    updateToggleState();

    // Update PFP visibility - drive from live values
    window.updatePfpVisibility = async function updatePfpVisibility() {
      try {
        const sdk = await getSdk();
        const inMini = await sdk.isInMiniApp();
        const show = !!inMini; // we'll wait for user later in getPfpUrl()

        if (show) {
          pfpOption.style.display = 'flex';
          console.log('‚úÖ PFP option shown - in miniapp context');
        } else {
          pfpOption.style.display = 'none';
          // If currently in PFP mode, switch back to mascot mode
          if (isPfpMode) {
            isMascotMode = true;
            isPfpMode = false;
            updateToggleState();
          }
          console.log('‚ùå PFP option hidden - not in miniapp context');
        }
      } catch (error) {
        console.log('‚ùå Error checking miniapp context:', error);
        pfpOption.style.display = 'none';
      }
    }

    // SDK loading helper - centralize SDK access
    let _sdk = null;
    async function getSdk() {
      if (_sdk) return _sdk;
      // Wait for SDK to be loaded
      while (!window.farcaster) {
        await new Promise(r => setTimeout(r, 50));
      }
      _sdk = window.farcaster;
      return _sdk;
    }


    // Don't run early visibility check - wait for SDK
    console.log('üîç Waiting for SDK before PFP visibility check...');



    // Sleep helper
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    // Ensure miniapp is ready
    async function ensureMiniAppReady() {
      const sdk = await getSdk();
      if (!(await sdk.isInMiniApp())) return false;
      try {
        await sdk.actions.ready?.();
      } catch { }
      return true;
    }


    // Safe property access for Proxy functions
    function safeGet(obj, path) {
      try {
        return path.split('.').reduce((acc, key) => {
          if (acc == null) return null;
          const val = acc[key];
          if (typeof val === 'function') {
            try {
              return val();
            } catch {
              return val;
            }
          }
          return val;
        }, obj);
      } catch {
        return null;
      }
    }

    // Extract value from Proxy function safely (async version)
    async function extractValue(proxyFunction) {
      try {
        if (typeof proxyFunction === 'function') {
          const result = proxyFunction();
          // If it returns a Promise, await it
          if (result && typeof result.then === 'function') {
            return await result;
          }
          return result;
        }
        return proxyFunction;
      } catch {
        return null;
      }
    }

    // Get user's PFP using signIn() - the standard miniapp approach
    async function getPfpUrl() {
      try {
        const sdk = await getSdk();

        // Check if we're in a miniapp
        if (!(await sdk.isInMiniApp())) {
          console.log('‚ùå Not in miniapp context');
          return null;
        }

        console.log('üîç Getting user PFP via signIn()...');

        // Make sure bridge is ready first
        if (sdk?.actions?.ready) {
          await sdk.actions.ready();
        }

        // Use proper Farcaster signIn() with nonce for native wallet interface
        let viewer;
        try {
          console.log('üîç Calling native Farcaster signIn() with nonce...');

          // Generate a proper alphanumeric nonce (SIWE requirement: min 8 chars, alphanumeric only)
          const nonce = `degenify${Date.now()}${Math.random().toString(36).substr(2, 9)}`;
          console.log('üîç Generated nonce:', nonce);

          // Call signIn() with nonce and acceptAuthAddress - this should launch native Farcaster wallet interface
          const result = await sdk.actions.signIn({
            nonce,
            acceptAuthAddress: true
          });
          console.log('üîç SignIn result:', result);

          // The result should contain the SIWF message and signature
          if (result && result.message) {
            console.log('‚úÖ SignIn successful, got message:', result.message);

            // Extract FID from the message - it's in the Resources section
            const message = result.message;
            console.log('üîç Full message:', message);

            // Look for FID in the message content (format: farcaster://fid/17064)
            const fidMatch = message.match(/farcaster:\/\/fid\/(\d+)/);
            if (fidMatch) {
              const fid = fidMatch[1]; // Keep as string for API call
              console.log('üîç Extracted FID:', fid);

              // Get PFP URL from our server using the FID
              console.log('üîç Fetching PFP from server for FID:', fid);
              const pfpResponse = await fetch('/api/fc-pfp', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fid })
              });

              if (pfpResponse.ok) {
                const pfpData = await pfpResponse.json();
                const pfpUrl = pfpData.pfpUrl;
                console.log('‚úÖ Got PFP URL from server:', pfpUrl);

                if (pfpUrl) {
                  // Create a mock viewer object with the PFP URL
                  viewer = { pfpUrl: pfpUrl };
                }
              } else {
                console.log('‚ö†Ô∏è Server PFP fetch failed:', pfpResponse.status);
              }
            } else {
              console.log('‚ö†Ô∏è Could not extract FID from message');
            }
          }

        } catch (e) {
          console.log("‚ö†Ô∏è SignIn failed:", e);

          // Handle specific error types
          if (e.name === 'RejectedByUser') {
            console.log("‚ùå User rejected the sign-in request");
            return null; // User cancelled, don't try fallbacks
          }

          // If signIn fails for other reasons, try fallback approaches
          try {
            console.log('üîç Trying fallback: direct context access...');
            const context = sdk.context;
            if (context && typeof context === 'object') {
              viewer = context.viewer || context.user;
              console.log('üîç Viewer from context fallback:', viewer);
            }
          } catch (contextError) {
            console.log("‚ö†Ô∏è Context fallback also failed:", contextError);
          }
        }

        if (viewer) {
          // Try multiple possible PFP URL paths
          let pfpUrl =
            viewer?.pfpUrl ??
            viewer?.pfp?.url ??
            viewer?.profileImage ??
            viewer?.avatarUrl ??
            null;

          console.log('üîç Raw PFP URL:', pfpUrl);

          // Some proxies wrap leaf props as functions too:
          if (typeof pfpUrl === "function") {
            try {
              pfpUrl = await pfpUrl();
              console.log('üîç Called PFP URL function:', pfpUrl);
            } catch { }
          }

          if (typeof pfpUrl === "string" && pfpUrl.length > 0) {
            console.log('‚úÖ Found real PFP URL:', pfpUrl);
            userPfpUrl = pfpUrl;
            return userPfpUrl;
          }
        }

        // If we get here, no PFP found - use placeholder for now
        console.log('üîç Using placeholder PFP since no real PFP found...');
        const placeholderPfpUrl = 'https://picsum.photos/400/400?random=1';
        console.log('‚úÖ Using placeholder PFP URL:', placeholderPfpUrl);
        userPfpUrl = placeholderPfpUrl;
        return userPfpUrl;

      } catch (error) {
        console.log('‚ùå Error getting PFP:', error);
        return null;
      }
    }

    // Initialize user PFP - just show the option, don't fetch PFP yet
    window.initializeUserPfp = async function initializeUserPfp() {
      console.log('üîç initializeUserPfp called - PFP option will be available');
      // Just ensure the PFP option is visible and ready
      // The actual PFP fetching will happen when they click "My PFP"
      pfpOption.style.opacity = '1';
      pfpOption.title = 'Click to degenify your profile picture (requires wallet signature)';
    }

    // Initialize user PFP
    initializeUserPfp();

    // Add PFP visibility to the retry mechanism
    const originalUpdateButtonVisibility = window.updateButtonVisibility;
    if (originalUpdateButtonVisibility) {
      window.updateButtonVisibility = async () => {
        await originalUpdateButtonVisibility();
        try {
          await updatePfpVisibility();
          // Also try to initialize PFP when SDK is ready
          console.log('üîç Calling initializeUserPfp from retry mechanism...');
          await initializeUserPfp();
        } catch (error) {
          console.log('‚ùå Error in updatePfpVisibility from retry:', error);
        }
      };
    }

    // Example button handlers
    document.querySelectorAll('.example-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const prompt = btn.dataset.prompt;
        promptInput.value = prompt;
        charCount.textContent = `${prompt.length}/500 characters`;
        generateBtn.disabled = false; // Enable button when example is selected
        promptInput.focus();
      });
    });

    // Enter key handler
    promptInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        generateImage();
      }
    });

    // Generate button handler
    generateBtn.addEventListener('click', generateImage);

    async function generateImage() {
      const prompt = promptInput.value.trim();
      if (!prompt) return;

      // Show loading state
      generatorForm.style.display = 'none';
      loadingState.style.display = 'flex';
      resultContainer.style.display = 'none';

      // Update loading message for PFP mode
      if (isPfpMode) {
        loadingState.innerHTML = '<div class="loading-spinner rotating-hat"></div><p>Degenifying your PFP... This may take a moment</p>';
      }

      try {
        // Validate and fetch PFP URL for PFP mode BEFORE creating request body
        if (isPfpMode && !userPfpUrl) {
          console.log('üîç PFP mode but no userPfpUrl, trying to fetch...');
          const pfp = await getPfpUrl();
          if (!pfp) {
            console.log('‚ùå PFP generation failed: could not fetch PFP URL');
            throw new Error('PFP URL not available. Please try again.');
          }
          userPfpUrl = pfp;
        }

        // Use different endpoint for PFP mode
        const endpoint = isPfpMode ? '/api/degenify-pfp' : '/api/generate';
        const requestBody = isPfpMode ? {
          prompt,
          pfpUrl: userPfpUrl,
          promptContext: currentPromptContext
        } : {
          prompt,
          baseImage: currentBaseImage,
          promptContext: currentPromptContext
        };

        // Ensure userPfpUrl is a valid string, not a Proxy function
        if (isPfpMode && userPfpUrl && typeof userPfpUrl !== 'string') {
          console.log('‚ùå PFP generation failed: userPfpUrl is not a string:', typeof userPfpUrl);
          throw new Error('Invalid PFP URL format. Please try again.');
        }

        console.log('üîç Generation request:', { endpoint, isPfpMode, userPfpUrl: isPfpMode ? userPfpUrl : 'N/A' });
        console.log('üîç Request body:', requestBody);
        console.log('üîç Prompt value:', prompt);
        console.log('üîç Prompt context:', currentPromptContext);

        // Retry logic for PFP generation (up to 3 attempts)
        let response;
        let lastError;
        const maxRetries = isPfpMode ? 3 : 1; // Only retry for PFP mode

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          console.log(`üîç Attempt ${attempt}/${maxRetries} for ${isPfpMode ? 'PFP' : 'regular'} generation`);

          response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
          });

          console.log(`üîç Response status (attempt ${attempt}):`, response.status);

          if (response.ok) {
            console.log(`‚úÖ Generation successful on attempt ${attempt}`);
            break; // Success, exit retry loop
          }

          // Log error details
          const errorText = await response.text();
          console.log(`‚ùå Server error response (attempt ${attempt}):`, errorText);
          lastError = errorText;

          // If this is not the last attempt, wait before retrying
          if (attempt < maxRetries) {
            console.log(`‚è≥ Waiting 1 second before retry ${attempt + 1}...`);

            // Update loading message to show retry
            if (isPfpMode) {
              loadingState.innerHTML = `<div class="loading-spinner rotating-hat"></div><p>Retrying PFP generation... Attempt ${attempt + 1}/${maxRetries}</p>`;
            }

            await new Promise(resolve => setTimeout(resolve, 1000)); // Reduced from 2s to 1s
          }
        }

        if (!response.ok) {
          throw new Error(`Generation failed after ${maxRetries} attempts. Last error: ${lastError}`);
        }

        const blob = await response.blob();
        const imageUrl = URL.createObjectURL(blob);
        resultImage.src = imageUrl;
        resultContainer.style.display = 'block';

        // Reload gallery to show new image
        await loadGallery();

      } catch (error) {
        alert('Failed: ' + error.message);
      } finally {
        // Hide loading state
        loadingState.style.display = 'none';
        generatorForm.style.display = 'block';
        promptInput.value = '';
        charCount.textContent = '0/500 characters';
      }
    }

    // Gallery pagination variables
    let allImages = [];
    let currentOffset = 0;
    const imagesPerLoad = 12;
    let isLoading = false;

    // Load gallery on page load
    async function loadGallery() {
      try {
        console.log('Loading gallery...');
        const response = await fetch('/api/gallery');
        console.log('Gallery response status:', response.status);
        const data = await response.json();
        console.log('Gallery data:', data);
        // The API returns the array directly, not wrapped in an object
        allImages = Array.isArray(data) ? data : (data.images || []);
        console.log('All images loaded:', allImages.length);
        currentOffset = 0;
        displayGallery();
      } catch (error) {
        console.error('Failed to load gallery:', error);
        allImages = [];
        displayGallery();
      }
    }

    // Display gallery images with pagination
    function displayGallery() {
      console.log('Displaying gallery, allImages length:', allImages.length);
      gallery.innerHTML = '';

      if (allImages.length === 0) {
        gallery.innerHTML = `
          <div class="empty-gallery">
            <h3>No images generated yet</h3>
            <p>Create your first meme above! üé©</p>
          </div>
        `;
        return;
      }

      // Show all images up to current offset + load amount
      const imagesToShow = allImages.slice(0, currentOffset + imagesPerLoad);
      console.log('Showing', imagesToShow.length, 'of', allImages.length, 'images');

      imagesToShow.forEach((img, index) => {
        const item = document.createElement('div');
        item.className = 'gallery-item';
        item.style.animationDelay = `${index * 0.1}s`;
        // Check if imageData is a URL (Cloudinary) or base64 data
        const imageSrc = img.imageData.startsWith('http') ? img.imageData : `data:image/png;base64,${img.imageData}`;

        item.innerHTML = `
          <div class="card-glass">
            <div class="gallery-image-container">
              <img src="${imageSrc}" alt="${img.prompt}"/>
              <div class="gallery-overlay">
                <div class="gallery-overlay-content">
                  <div class="gallery-actions">
                    <div class="gallery-action-group">
                      <button class="gallery-action-btn" onclick="handleShare('${img.id}')">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                          <path d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 1 1 0-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 1 1 5.367-2.684 3 3 0 0 1-5.367 2.684zm0 9.316a3 3 0 1 1 5.367 2.684 3 3 0 0 1-5.367-2.684z"/>
                        </svg>
                      </button>
                    </div>
                    <button class="gallery-download-btn" onclick="downloadImage('${img.id}')">
                      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7,10 12,15 17,10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                      </svg>
                    </button>
                  </div>
                </div>
              </div>
            </div>
            <p class="gallery-prompt">${img.prompt}</p>
          </div>
        `;
        gallery.appendChild(item);
      });
    }

    // Infinite scroll functions
    function loadMoreImages() {
      if (isLoading || currentOffset + imagesPerLoad >= allImages.length) {
        return;
      }

      isLoading = true;
      const loadingIndicator = document.getElementById('loadingIndicator');
      if (loadingIndicator) loadingIndicator.classList.remove('hidden');

      // Simulate loading delay for better UX
      setTimeout(() => {
        currentOffset += imagesPerLoad;
        displayGallery();
        isLoading = false;
        if (loadingIndicator) loadingIndicator.classList.add('hidden');
      }, 500);
    }

    // Intersection Observer for infinite scroll
    function setupInfiniteScroll() {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && currentOffset + imagesPerLoad < allImages.length) {
            loadMoreImages();
          }
        });
      }, {
        rootMargin: '100px'
      });

      // Observe the loading indicator
      const loadingIndicator = document.getElementById('loadingIndicator');
      if (loadingIndicator) {
        observer.observe(loadingIndicator);
      }
    }

    // Download image function - make it globally accessible
    window.downloadImage = async function (imageId) {
      const context = await window.detectFarcasterContext();
      console.log('üîΩ Download attempt in context:', context);

      // MINIAPP: Use navigation-based download, WEBSITE: Use programmatic download
      if (context.isFarcasterMiniapp) {
        console.log('üîΩ MINIAPP: Opening download URL directly (navigation-based)');
        const downloadUrl = `${window.location.origin}/api/download/${imageId}`;

        // Try to open in new tab/window - miniapp should handle this
        try {
          window.open(downloadUrl, '_blank');
          console.log('‚úÖ MINIAPP: Opened download URL in new tab');
        } catch (error) {
          console.log('‚ùå MINIAPP: New tab failed, trying direct navigation');
          // Fallback: direct navigation
          window.location.href = downloadUrl;
        }
        return;
      }

      // WEBSITE: Use traditional programmatic download (direct to Downloads folder)
      console.log('üîΩ WEBSITE: Using programmatic download (blob + link.click)');
      fetch(`/api/download/${imageId}`)
        .then(response => {
          if (!response.ok) {
            throw new Error('Download failed');
          }
          return response.blob();
        })
        .then(blob => {
          const url = window.URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `meme-${imageId}.png`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          window.URL.revokeObjectURL(url);
          console.log('‚úÖ BROWSER: Download completed');
        })
        .catch(error => {
          console.error('‚ùå Download failed:', error);
          alert('Download failed: ' + error.message);
        });
    };

    // Handle like function - make it globally accessible
    window.handleLike = function (imageId) {
      console.log('Liked image:', imageId);
      // Add like functionality here if needed
    };

    // Handle share function - make it globally accessible
    window.handleShare = function (imageId) {
      showShareModal(imageId);
    };

    // Show share modal with X and Farcaster options
    function showShareModal(imageId) {
      // Create modal overlay
      const modal = document.createElement('div');
      modal.className = 'share-modal-overlay';
      modal.innerHTML = `
        <div class="share-modal">
          <div class="share-modal-header">
            <h3>Share this creation</h3>
            <button class="share-modal-close" onclick="closeShareModal()">&times;</button>
          </div>
          <div class="share-modal-content">
            <p>Choose where to share:</p>
            <div class="share-options">
              <button class="share-option-btn" onclick="shareToX('${imageId}')">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                </svg>
                Share on X
              </button>
              <button class="share-option-btn" onclick="shareToFarcaster('${imageId}')">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                Share on Farcaster
              </button>
            </div>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      // Lock body scroll when modal is open
      document.body.style.overflow = 'hidden';

      // Close modal when clicking overlay
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          closeShareModal();
        }
      });
    }

    // Close share modal - make globally accessible
    window.closeShareModal = function () {
      // Remove ONLY share modals, not gallery overlays
      const shareModals = document.querySelectorAll('.share-modal-overlay');
      shareModals.forEach(modal => modal.remove());

      // Reset body scroll only
      document.body.style.overflow = '';

      // Don't touch other overlays or gallery elements
    };

    // Share to X (Twitter) - make globally accessible
    window.shareToX = function (imageId) {
      const shareUrl = `${window.location.origin}/api/share/${imageId}`;
      const text = `Check out this epic degeneration I created with Degenify! üé© üî• 
Create yours on ${window.location.origin}

$DEGEN @degentokenbase`;
      const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(shareUrl)}`;
      window.open(twitterUrl, '_blank');
      // Close modal immediately
      closeShareModal();
    };

    // OFFICIAL Farcaster SDK detection function
    window.detectFarcasterContext = async function () {
      const isMobile = /Mobile|iPhone|iPad|Android/i.test(window.navigator.userAgent);

      // Use official SDK methods for reliable detection
      let isInMiniApp = false;
      let platform = 'web';
      let client = null;

      if (window.farcaster && window.farcaster.isInMiniApp) {
        try {
          isInMiniApp = await window.farcaster.isInMiniApp();
          console.log('üîç SDK isInMiniApp():', isInMiniApp);
        } catch (error) {
          console.log('‚ùå isInMiniApp() failed:', error);
        }
      }

      if (window.farcaster && window.farcaster.context) {
        try {
          const ctx = window.farcaster.context;
          platform = ctx.platform || 'web';
          client = ctx.client?.id || null;
          console.log('üîç SDK context:', { platform, client });
        } catch (error) {
          console.log('‚ùå context access failed:', error);
        }
      }

      // Determine environment
      const isFarcasterMiniapp = isInMiniApp;
      const isMiniappMobile = isInMiniApp && platform === 'mobile';
      const isMiniappDesktop = isInMiniApp && platform === 'web';
      const isWebsite = !isInMiniApp;

      // Capabilities check
      const hasSDK = !!(window.farcaster && window.farcaster.actions);
      const hasComposeCast = !!(hasSDK && window.farcaster.actions.composeCast);
      const hasAddMiniApp = !!(hasSDK && window.farcaster.actions.addMiniApp);

      // Decision logic
      const shouldUseSDK = isFarcasterMiniapp && hasComposeCast;
      const shouldShowButton = isFarcasterMiniapp && hasAddMiniApp;

      console.log('üîç OFFICIAL SDK DETECTION:');
      console.log('- isMobile (UA):', isMobile);
      console.log('- isInMiniApp:', isInMiniApp);
      console.log('- platform:', platform);
      console.log('- client:', client);
      console.log('- isFarcasterMiniapp:', isFarcasterMiniapp);
      console.log('- isMiniappMobile:', isMiniappMobile);
      console.log('- isMiniappDesktop:', isMiniappDesktop);
      console.log('- isWebsite:', isWebsite);
      console.log('- hasSDK:', hasSDK);
      console.log('- hasComposeCast:', hasComposeCast);
      console.log('- hasAddMiniApp:', hasAddMiniApp);
      console.log('- shouldUseSDK:', shouldUseSDK);
      console.log('- shouldShowButton:', shouldShowButton);

      return {
        isMobile,
        isInMiniApp,
        platform,
        client,
        isFarcasterMiniapp,
        isMiniappMobile,
        isMiniappDesktop,
        isWebsite,
        hasSDK,
        hasComposeCast,
        hasAddMiniApp,
        shouldUseSDK,
        shouldShowButton,
        userAgent: window.navigator.userAgent.substring(0, 100)
      };
    };

    // Share to Farcaster - make globally accessible
    window.shareToFarcaster = async function (imageId) {
      const shareUrl = `${window.location.origin}/api/share/${imageId}`;
      const text = `Check out this epic degeneration I created with Degenify! üé© üî• 

${shareUrl}

$DEGEN /degen 
Create yours on www.degenify.xyz`;

      const context = await window.detectFarcasterContext();
      console.log('üîç SHARE CONTEXT:', context);
      console.log('üîç SHARE: isFarcasterMiniapp =', context.isFarcasterMiniapp);

      // MINIAPP: Use native SDK sharing, WEBSITE: Use browser fallback
      if (context.isFarcasterMiniapp) {
        console.log('üéØ Using Farcaster SDK for sharing');
        try {
          const result = window.farcaster.actions.composeCast({
            text: text,
            embeds: [shareUrl]
          });

          if (result && typeof result.then === 'function') {
            result.then(() => {
              console.log('‚úÖ SDK sharing successful');
              closeShareModal();
            }).catch(error => {
              console.log('‚ùå SDK failed, fallback to browser:', error);
              const farcasterUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(text)}`;
              window.open(farcasterUrl, '_blank');
              closeShareModal();
            });
          } else {
            console.log('‚úÖ SDK call completed (no promise)');
            closeShareModal();
          }
        } catch (error) {
          console.log('‚ùå SDK threw error, fallback to browser:', error);
          const farcasterUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(text)}`;
          window.open(farcasterUrl, '_blank');
          closeShareModal();
        }
      } else {
        console.log('üåê WEBSITE: Using browser method (Warpcast URL)');
        const farcasterUrl = `https://warpcast.com/~/compose?text=${encodeURIComponent(text)}`;
        window.open(farcasterUrl, '_blank');
        closeShareModal();
      }
    };

    // Add to Farcaster function
    window.addToFarcaster = function () {
      if (window.farcaster && window.farcaster.actions && window.farcaster.actions.addMiniApp) {
        window.farcaster.actions.addMiniApp().then(() => {
          console.log('Added miniapp to home screen successfully');
        }).catch(error => {
          console.error('Failed to add miniapp to home screen:', error);
        });
      } else {
        // This should not happen since button is only shown when SDK is available
        console.error('Farcaster SDK or addMiniApp not available');
      }
    };

    // Global cleanup function for emergencies
    window.forceCleanup = function () {
      // Remove ALL modals and overlays
      const allModals = document.querySelectorAll('[class*="modal"], [class*="overlay"]');
      allModals.forEach(el => el.remove());

      // Reset only specific styles, preserve background
      document.body.style.overflow = '';
      document.documentElement.style.overflow = '';

      console.log('Force cleanup completed');
    };

    // Initialize button state
    generateBtn.disabled = true;

    // Check if there's already text in the input (fallback)
    if (promptInput.value.length > 0) {
      generateBtn.disabled = false;
    }

    // Load gallery on page load
    loadGallery();

    // Setup infinite scroll
    setupInfiniteScroll();

    // Farcaster Mini App - white background and immediate ready() call
    const isInFarcaster = window.location !== window.parent.location ||
      window.navigator.userAgent.includes('Farcaster') ||
      document.referrer.includes('farcaster');

    if (isInFarcaster) {
      document.body.style.backgroundColor = '#ffffff';
      document.documentElement.style.backgroundColor = '#ffffff';

      // Try to call ready() immediately if SDK is already available
      if (window.farcaster && window.farcaster.actions) {
        window.farcaster.actions.ready();
        console.log('Called ready() immediately via window.farcaster');
      }
    }

  </script>

  <!-- Farcaster Mini App SDK -->
  <script type="module">
    // More robust Farcaster detection
    const isInFarcaster = window.location !== window.parent.location ||
      window.navigator.userAgent.includes('Farcaster') ||
      document.referrer.includes('farcaster') ||
      window.location.hostname.includes('farcaster') ||
      document.title.includes('Farcaster') ||
      window.location.search.includes('farcaster') ||
      window.location.hash.includes('farcaster');

    console.log('Farcaster detection:', {
      isInFarcaster,
      isIframe: window.location !== window.parent.location,
      userAgent: window.navigator.userAgent.includes('Farcaster'),
      referrer: document.referrer.includes('farcaster'),
      hostname: window.location.hostname.includes('farcaster'),
      title: document.title.includes('Farcaster'),
      search: window.location.search.includes('farcaster'),
      hash: window.location.hash.includes('farcaster'),
      fullUrl: window.location.href,
      userAgentFull: window.navigator.userAgent
    });

    // Try to load SDK - but validate it has proper capabilities
    console.log('üì± Loading Farcaster SDK - conditional load');
    import('https://esm.sh/@farcaster/miniapp-sdk').then(({ sdk }) => {
      console.log('Farcaster SDK loaded successfully', sdk);

      // Make SDK globally available
      window.farcaster = sdk;

      // Validate SDK has required capabilities
      const hasValidCapabilities = sdk.actions &&
        typeof sdk.actions.composeCast === 'function' &&
        typeof sdk.actions.addMiniApp === 'function';

      console.log('SDK capabilities validation:', hasValidCapabilities);

      if (!hasValidCapabilities) {
        console.log('‚ö†Ô∏è SDK loaded but lacks required capabilities - treating as regular browser');
        // Don't expose SDK if capabilities are missing
        window.farcaster = null;
        return;
      }

      // Debug: Log available actions
      console.log('Available SDK actions:', Object.keys(sdk.actions || {}));
      console.log('SDK actions object:', sdk.actions);
      console.log('composeCast available:', !!sdk.actions.composeCast);
      console.log('addMiniApp available:', !!sdk.actions.addMiniApp);

      // OFFICIAL SDK: Show button only in miniapp context
      const updateButtonVisibility = async () => {
        const buttonContext = await window.detectFarcasterContext();
        const addToFarcasterBtn = document.querySelector('.add-to-farcaster-btn');

        console.log('üîç Button context check:', buttonContext);

        // Show button only in actual miniapp context
        if (addToFarcasterBtn && buttonContext.isFarcasterMiniapp && buttonContext.shouldShowButton) {
          addToFarcasterBtn.style.display = 'inline-flex';
          addToFarcasterBtn.style.alignItems = 'center';
          console.log('‚úÖ SHOWING Add miniapp button - in miniapp context');
        } else if (addToFarcasterBtn) {
          addToFarcasterBtn.style.display = 'none';
          console.log('‚ùå HIDING button - not in miniapp context or SDK not ready');
        }

        // Also update PFP option visibility and initialize PFP
        await updatePfpVisibility();
        await initializeUserPfp();
      };

      // Initial check
      updateButtonVisibility();

      // REDUCED RETRIES: Check every 1000ms for 3 seconds for SDK loading
      console.log('üîÑ Setting up retry logic for SDK loading');
      let attempts = 0;
      const maxAttempts = 3; // 3 seconds / 1000ms
      const retryInterval = setInterval(async () => {
        attempts++;
        console.log(`üîÑ SDK retry attempt ${attempts}/${maxAttempts}`);
        await updateButtonVisibility();

        // Stop if SDK is loaded or max attempts reached
        if (window.farcaster?.actions?.addMiniApp || attempts >= maxAttempts) {
          clearInterval(retryInterval);
          console.log('üîÑ SDK retry stopped:', window.farcaster?.actions?.addMiniApp ? 'SDK loaded' : 'Max attempts reached');
        }
      }, 1000);

      // Mobile-specific ready() solution - wait for full SDK initialization
      let readyCallCount = 0;
      const maxReadyAttempts = 20;

      const waitForSDKAndCallReady = () => {
        readyCallCount++;
        console.log(`üîÑ Ready attempt ${readyCallCount}/${maxReadyAttempts}`);

        try {
          // Check if SDK is fully initialized
          if (sdk && sdk.actions && typeof sdk.actions.ready === 'function') {
            console.log('üì± SDK fully available, calling ready()...');
            sdk.actions.ready();
            console.log('‚úÖ Successfully called sdk.actions.ready()!');
            return; // Success, stop trying
          } else {
            console.log('‚è≥ SDK not fully ready yet, will retry...');
          }
        } catch (error) {
          console.log('‚ùå Ready() call failed:', error);
        }

        // If we haven't succeeded and haven't reached max attempts, try again
        if (readyCallCount < maxReadyAttempts) {
          setTimeout(waitForSDKAndCallReady, 200); // Try every 200ms
        } else {
          console.log('üö® Max ready() attempts reached, giving up');
          // Last ditch effort - try calling on window.farcaster if it exists
          if (window.farcaster && window.farcaster.actions && window.farcaster.actions.ready) {
            try {
              window.farcaster.actions.ready();
              console.log('‚úÖ Fallback ready() call successful');
            } catch (e) {
              console.log('‚ùå Fallback ready() call failed:', e);
            }
          }
        }
      };

      // Start the ready() attempts immediately
      waitForSDKAndCallReady();

      // Also try when DOM is fully loaded as backup
      if (document.readyState === 'complete') {
        setTimeout(waitForSDKAndCallReady, 100);
      } else {
        window.addEventListener('load', () => {
          setTimeout(waitForSDKAndCallReady, 100);
        });
      }
    }).catch(error => {
      console.error('Failed to load Farcaster SDK:', error);
      // If SDK fails to load, still try to call ready on window.farcaster if it exists
      if (window.farcaster && window.farcaster.actions) {
        window.farcaster.actions.ready();
        console.log('Called ready() via window.farcaster fallback');
      }
    });

    // Also try calling ready() immediately if SDK is already available (like in working version)
    if (window.farcaster && window.farcaster.actions) {
      window.farcaster.actions.ready();
      console.log('Called ready() immediately via window.farcaster');
    }
  </script>
</body>

</html>